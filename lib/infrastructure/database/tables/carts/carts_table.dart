
import 'package:dartz/dartz.dart';
import 'package:ecommerce_app/domain/cart/interface/i_cart_repository.dart';
import 'package:ecommerce_app/domain/product/interface/i_product_repository.dart';
import 'package:ecommerce_app/infrastructure/database/core/obay_database.dart';
import 'package:injectable/injectable.dart';
import 'package:moor_flutter/moor_flutter.dart';

part 'carts_table.g.dart';


class Carts extends Table{
  // User id is generated by the firebase auth. hence there is no need to generate one using AUTO INCREMENT
  TextColumn get userID => text().customConstraint('NOT NULL')();
  TextColumn get productID => text().customConstraint('NOT NULL')();
  IntColumn get productQuantity => integer().customConstraint('NOT NULL CHECK (product_quantity > 0)')();
  IntColumn get totalPrice => integer()();


  //Set userID as primary Key
  @override
  Set<Column> get primaryKey => {productID};
}
// User Table Data Access Object
@LazySingleton(as: ICartRepository)
@UseDao(tables: [Carts])
class CartDAO extends DatabaseAccessor<ObayDatabase> with _$CartDAOMixin implements ICartRepository{
  final ObayDatabase db;
  // Called by the OBayDatabase class
  CartDAO(this.db) : super(db);

  @override
  Future<Either<String,Unit>> addCart(CartsCompanion cart) async {
    //Add A single cart instance containing [userID,productID,productQuantity and Total Price] to the Carts Table
    try{
      await into(carts).insert(cart);
      return right(unit);
    }
    on InvalidDataException catch(e){
      print(e.message);
      return left("Error Occured While Inserting");
    }

  }

  @override
  Future<Either<String,Unit>> changeProductQuantity(CartsCompanion cart) async {
    try {
      await update(carts).replace(cart);
      return right(unit);
    }
    on MoorWrappedException catch (e) {
      print(e.message);
      return left("Error Occurred While Updating Quantity");
    }
  }

  @override
  Future<Either<String,List<Cart>>> getUserCart(String uID)async {
    try {
      final  _userCart = await (select(carts)..where((t) => t.userID.equals(uID))).get();
      return right(_userCart);
    }
    on MoorWrappedException catch (e) {
      print(e.message);
      return left("Error Occured While Fetching User Carts");
    }
  }

  @override
  Future<Either<String,Unit>> removeFromCart(CartsCompanion cart) async {
    try {
      await delete(carts).delete(cart);
      return right(unit);
    }
    on MoorWrappedException catch (e) {
      print(e.message);
      return left("Error Occured While Deleting Cart");
    }

  }

  //Check To See If A Cart ALready Exists : This will be used in inserting/ updating products.
  @override
  Future<bool> cartAlreadyExists(CartsCompanion cart) async{
    try{
      final  _carts = await (select(carts)..where((t) => t.productID.equals(cart.productID.value))).get();
      return _carts.isNotEmpty;
    }
    catch(e){
      return false;
    }


  }

  @override
  Stream<Either<String, List<Cart>>> watchUserCart(String uID){
    print("Watch Ran");
      return (select(carts)..where((t) => t.userID.equals(uID))).watch().map((cart) => right(cart));
  }

  @override
  Future<Either<String, Cart>> getCartFromProductID(String uID, String productID) async{
    try {
      final  _userCart = await (select(carts)..where((t) => t.userID.equals(uID) & t.productID.equals(productID))).getSingle();
      return right(_userCart);
    }
    on MoorWrappedException catch (e) {
      print(e.message);
      return left("Error Occured While Fetching Product Cart");
    }
  }

  @override
  Future deleteAllItemsFromCart(String uID) {
    return (delete(carts)..where((tbl) => carts.userID.equals(uID))).go();
  }

}
